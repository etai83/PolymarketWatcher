
import { Trade, DashboardStats } from '../types';

/**
 * Generates realistic price history and trades for a specific market
 */
const generateMarketHistory = (marketName: string, wallet: string): Trade[] => {
  const basePrice = 0.45; // Starting prob
  let currentPrice = basePrice;
  const trades: Trade[] = [];
  const now = Date.now();
  const oneDay = 3600000 * 24;
  
  // Generate 40-60 trades
  const tradeCount = Math.floor(Math.random() * 20) + 40;

  for (let i = 0; i < tradeCount; i++) {
    // Random walk price
    const change = (Math.random() - 0.5) * 0.1;
    currentPrice = Math.max(0.01, Math.min(0.99, currentPrice + change));
    
    // Time distribution (older to newer)
    const timeOffset = (tradeCount - i) * (oneDay / 4) + (Math.random() * oneDay); // Spread over a few weeks
    
    const isBuy = Math.random() > 0.45; // Slightly more buys usually
    
    // Whale size generation: Mix of small probes and large convictions
    // Skew random towards larger numbers for "Whale" feel
    // Size is in Shares
    const sizeBase = Math.random(); 
    let size;
    if (sizeBase > 0.9) {
        size = Math.floor(Math.random() * 15000) + 5000; // Super conviction: 5k-20k shares
    } else if (sizeBase > 0.6) {
        size = Math.floor(Math.random() * 4000) + 1000; // Medium: 1k-5k shares
    } else {
        size = Math.floor(Math.random() * 900) + 100; // Small: 100-1000 shares
    }

    trades.push({
      id: `trade-${i}`,
      timestamp: new Date(now - timeOffset).toISOString(),
      market: marketName,
      side: isBuy ? 'BUY' : 'SELL',
      size: size,
      price: currentPrice,
      total: size * currentPrice, // Total USD Value
      outcome: 'OPEN'
    });
  }

  // Sort by date descending
  return trades.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
};

/**
 * Simulates an async fetch to a scraper/indexer
 */
export const fetchWalletTradesOnMarket = async (wallet: string, marketName: string): Promise<Trade[]> => {
  return new Promise((resolve) => {
    // Simulate network delay for "scraping"
    setTimeout(() => {
      resolve(generateMarketHistory(marketName, wallet));
    }, 1500);
  });
};

/**
 * Parses CSV data generated by scrape_trades.py
 */
export const processCsvData = (csvText: string): Trade[] => {
  const lines = csvText.split('\n');
  if (lines.length < 2) return [];

  // Parse headers
  const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
  
  const getIdx = (name: string) => headers.indexOf(name);
  
  const idxTimestamp = getIdx('timestampIso');
  const idxMarket = getIdx('marketQuestion');
  const idxSide = getIdx('side');
  const idxSize = getIdx('size');
  const idxPrice = getIdx('price');
  const idxUsdc = getIdx('usdcSize');
  const idxOutcome = getIdx('outcome');
  const idxHash = getIdx('transactionHash');

  const trades: Trade[] = [];

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // Handle CSV parsing with quotes
    const values: string[] = [];
    let currentVal = '';
    let inQuotes = false;
    
    for (let j = 0; j < line.length; j++) {
      const char = line[j];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        values.push(currentVal);
        currentVal = '';
      } else {
        currentVal += char;
      }
    }
    values.push(currentVal);

    const clean = (val: string | undefined) => val ? val.replace(/^"|"$/g, '').replace(/""/g, '"').trim() : '';

    const timestamp = clean(values[idxTimestamp]);
    if (!timestamp) continue;

    const size = parseFloat(clean(values[idxSize]) || '0');
    const price = parseFloat(clean(values[idxPrice]) || '0');
    const usdc = parseFloat(clean(values[idxUsdc]) || '0');
    const rawSide = clean(values[idxSide]).toUpperCase();
    const side = (rawSide === 'BUY' || rawSide === 'SELL') ? rawSide : 'BUY';

    trades.push({
      id: clean(values[idxHash]) || `csv-${i}`,
      timestamp: timestamp,
      market: clean(values[idxMarket]) || 'Unknown Market',
      side: side,
      size: size,
      price: price,
      total: usdc > 0 ? usdc : (size * price), // Prefer USDC size if available
      outcome: clean(values[idxOutcome]) || 'Unknown'
    });
  }

  return trades.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
};

export const calculateStats = (trades: Trade[]): DashboardStats => {
  const totalVolume = trades.reduce((sum, t) => sum + t.total, 0);
  const buyVolume = trades.filter(t => t.side === 'BUY').reduce((sum, t) => sum + t.total, 0);
  const sellVolume = trades.filter(t => t.side === 'SELL').reduce((sum, t) => sum + t.total, 0);
  
  // Estimate PnL based on VWAP logic
  const pnl = sellVolume - (buyVolume * 0.85); // Mock positive PnL bias for "Whales"

  const winningTrades = trades.filter(t => t.price > 0.6 && t.side === 'BUY' || t.price < 0.4 && t.side === 'SELL').length;

  return {
    totalTrades: trades.length,
    totalVolume,
    pnl,
    winRate: trades.length > 0 ? winningTrades / trades.length : 0,
    averageTradeSize: trades.length > 0 ? totalVolume / trades.length : 0
  };
};
